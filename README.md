# AtomicWriter 🛡️

안전하고 **원자적인 파일 쓰기**를 지원하는 경량 Python 라이브러리입니다.  
Pandas, Polars, NumPy 등 데이터 객체 저장 시 **파일 손상 없이**, **트랜잭션처럼 안전하게 처리**할 수 있습니다.

---

## 🌟 주요 기능

- ✅ 임시 디렉토리 스테이징 후 **원자적 파일 교체**  
- 📦 Pandas, Polars, NumPy 등 다양한 데이터 객체 지원  
- 📍 `_SUCCESS` 플래그 파일 생성 — 저장 완료 여부 표시  
- 🛠 실패 시 **원본 파일 보존**, 임시 파일 자동 정리  
- 🧩 플러그인 아키텍처로 **확장성 좋음**

---

## 🧠 왜 이 도구가 정말 중요한가요?

NumPy나 Pandas는 데이터 분석에서는 최적이지만, **파일로 저장할 때는 아래와 같은 위험**이 있습니다:

1. **파일 일부만 저장되어 깨질 수 있음** — 강제 종료나 오류 시
2. **동시 쓰기 충돌** — 멀티프로세스 환경에서 파일이 엉킬 수 있음
3. **플랫폼 간 동작 차이** — Windows와 Linux/macOS에서 파일 시스템 동작이 다름

AtomicWriter는 임시 파일에 쓰고 **단일 `rename()`/`replace()` 작업으로 교체**합니다.  
이 방식은 **“완전히 저장되거나 전혀 저장되지 않는”** 원자성(atomicity)을 보장하며,  
- POSIX: `os.replace` (atomic), `fsync`  
- Windows: `MoveFileEx`, `Commit`  
를 활용하여 파일이 **항상 일관된 상태**를 유지하도록 합니다 :contentReference[oaicite:1]{index=1}.

---

## ⚙️ 설치

```bash
pip install atomicwriter

## 🛠️ 사용 예제

```python
import atomicwriter as aw
import pandas as pd

df = pd.DataFrame({"a": [1, 2, 3]})
aw.write(df, "output.parquet", format="parquet")
# │→ 임시 파일 작성 → 원자적 교체 → _SUCCESS 생성
# │→ 실패 시 원본 보존, 임시 파일 자동 정리

## 💡 빅데이터 워크플로우에서 활용 시나리오

| 시나리오               | 해결 방법                   | 장점                    |
|------------------------|-----------------------------|-------------------------|
| Pandas → CSV 저장      | 임시 파일에 기록 후 교체    | CSV 파일 깨짐 방지      |
| 멀티프로세스 병렬 쓰기 | atomic replace 방식 사용    | 충돌 없는 안전 저장     |
| 데이터 파이프라인 작업 | 저장 성공 시 `_SUCCESS` 확인 | 데이터 완전성 보장      |

---

## 🔄 비교 – 유사 라이브러리 특징 정리

### [python-atomicwrites](https://github.com/untitaker/python-atomicwrites)
- 간편한 API
- Windows 지원
- 크로스 플랫폼 호환

### atomicwriter (본 프로젝트)
- ✅ 경량
- ✅ 플러그인 아키텍처
- ✅ Pandas / Polars / Numpy 등 데이터 객체 중심 저장 지원

---

## ✅ 라이선스

Apache 2.0 — 기업 및 커뮤니티 모두 자유롭게 사용 가능

---

## ✨ 요약

**AtomicWriter**는 분석만큼 중요한 **“저장” 단계를 안전하게 처리**하는 도구입니다.

특히 데이터 무결성이 중요한 환경에서  
(예: 머신러닝 배치, 멀티프로세스 분석, 중요 로그 저장 등)  
**작지만 강력한 해결책**을 제공합니다.

📘 시나리오 1: Pandas CSV 저장 중 작업 중단
문제 상황:
한 사용자가 Pandas로 대용량 분석 결과를 .csv 파일로 저장하던 중, 예상치 못한 전원 차단이나 커널 강제 종료가 발생했습니다.
결과 파일은 50MB 중 3MB만 저장된 채 손상되었고, 이후 읽기도 되지 않았습니다.

AtomicWriter로 해결:
임시 파일에 먼저 기록 후, 모든 쓰기가 성공해야만 원본과 교체됩니다.
따라서 중간에 꺼져도 기존 파일은 보존되고, 손상된 임시 파일은 자동 정리되어 안정성을 확보할 수 있습니다.

📘 시나리오 2: 멀티프로세스 환경에서 경쟁 조건(Race Condition)
문제 상황:
Python multiprocessing 기반 데이터 수집 파이프라인에서 여러 프로세스가 동시에 같은 파일을 저장하며 충돌이 발생했습니다.
결과적으로 로그 파일이 덮어쓰여 누락되거나, 일부 JSON 파일은 파싱할 수 없는 손상된 형태로 저장됐습니다.

AtomicWriter로 해결:
파일 쓰기를 atomic replace 방식으로 수행하면, 한 번에 하나의 프로세스만 최종 경로로 이동할 수 있습니다.
이로써 경쟁 조건 없이 충돌 없이 저장이 보장됩니다.

📘 시나리오 3: 데이터 파이프라인 검증 불가
문제 상황:
ETL 작업에서 .parquet 저장이 완료됐는지 여부를 자동 시스템이 판단할 수 없어, 손상되거나 미완성된 데이터를 다음 단계에서 그대로 사용했습니다.
결과적으로 모델 학습 데이터에 결측값이 포함되어 품질 저하가 발생했습니다.

AtomicWriter로 해결:
저장이 성공적으로 완료된 경우에만 _SUCCESS 플래그 파일을 함께 생성하도록 설정할 수 있습니다.
후속 단계는 _SUCCESS 유무를 기준으로 안전하게 파이프라인을 구동할 수 있습니다.

📘 시나리오 4: Polars DataFrame을 S3로 저장 중 오류 발생
문제 상황:
Polars DataFrame을 AWS S3에 직접 저장하는 중간에 ConnectionError가 발생하여 S3에는 부분적으로 깨진 .parquet 파일이 올라갔습니다.
다음 번 실행에서 이 파일을 재사용하려 했지만, S3에서 파일이 손상된 채로 존재해 오류를 유발했습니다.

AtomicWriter로 해결:
로컬 임시 파일에 완전히 저장된 후에만 S3 업로드 또는 교체가 수행됩니다.
네트워크 이슈나 디스크 오류에도 최종 파일은 항상 완전한 상태로만 존재하게 됩니다.